[[jc-webflux]]
= WebFlux Security

Spring Security's WebFlux support relies on a `WebFilter` and works the same for Spring WebFlux and Spring WebFlux.Fn.
You can find a few sample applications that demonstrate the code below:

* Hello WebFlux {gh-samples-url}/boot/hellowebflux[hellowebflux]
* Hello WebFlux.Fn {gh-samples-url}/boot/hellowebfluxfn[hellowebfluxfn]
* Hello WebFlux Method {gh-samples-url}/boot/hellowebflux-method[hellowebflux-method]


== Minimal WebFlux Security Configuration

You can find a minimal WebFlux Security configuration below:

.Minimal WebFlux Security Configuration
====
.Java
[source,java,role="primary"]
-----

@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}
-----

.Kotlin
[source,kotlin,role="secondary"]
-----
@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }
}
-----
====

This configuration provides form and http basic authentication, sets up authorization to require an authenticated user for accessing any page, sets up a default log in page and a default log out page, sets up security related HTTP headers, CSRF protection, and more.

== Explicit WebFlux Security Configuration

You can find an explicit version of the minimal WebFlux Security configuration below:

.Explicit WebFlux Security Configuration
====
.Java
[source,java,role="primary"]
-----
@Configuration
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}

	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http
			.authorizeExchange(exchanges -> exchanges
			    .anyExchange().authenticated()
			)
			.httpBasic(withDefaults())
			.formLogin(withDefaults());
		return http.build();
	}
}
-----

.Kotlin
[source,kotlin,role="secondary"]
-----
@Configuration
@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }

    @Bean
    fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            formLogin { }
            httpBasic { }
        }
    }
}
-----
====

This configuration explicitly sets up all the same things as our minimal configuration.
From here you can easily make the changes to the defaults.

You can find more examples of explicit configuration in unit tests, by searching https://github.com/spring-projects/spring-security/search?q=path%3Aconfig%2Fsrc%2Ftest%2F+EnableWebFluxSecurity[EnableWebFluxSecurity in the `config/src/test/` directory].

[[jc-webflux-multiple-filter-chains]]
=== Multiple chains support

We can configure multiple `SecurityWebFilterChain` instances.

For example, the following is an example of having a specific configuration for URL's that start with `/api/`. This overrides the form login configuration with lower precedence.

[source,java]
----
	@EnableWebFluxSecurity
	@Import(ReactiveAuthenticationTestConfiguration.class)
	static class MultiSecurityHttpConfig {

		@Order(Ordered.HIGHEST_PRECEDENCE)                                                      <1>
		@Bean
		SecurityWebFilterChain apiHttpSecurity(ServerHttpSecurity http) {
			http
                    .securityMatcher(new PathPatternParserServerWebExchangeMatcher("/api/**"))  <2>
                    .authorizeExchange()
					    .anyExchange().denyAll();
			return http.build();
		}

		@Bean
    	SecurityWebFilterChain webFormHttpSecurity(ServerHttpSecurity http) {                   <3>
            http
                .authorizeExchange((exchanges) ->
                    exchanges
                        .pathMatchers("/login").permitAll()
                        .anyExchange().authenticated()
                )
                .httpBasic(withDefaults())
                .formLogin((formLogin) ->                                                       <4>
                    formLogin
                        .loginPage("/login")
                );
		    return http.build();
	    }

        @Bean
    	public static ReactiveUserDetailsService userDetailsService() {
    		return new MapReactiveUserDetailsService(PasswordEncodedUser.user(), PasswordEncodedUser.admin());
    	}

	}

----

<1> Configure a SecurityWebFilterChain with an `@Order` to specify which `SecurityWebFilterChain` should be considered first
<2> The `PathPatternParserServerWebExchangeMatcher` states that this `SecurityWebFilterChain` will only be applicable to URLs that start with `/api/`
<3> Create another instance of `SecurityWebFilterChain` with lower precedence.
<4> Some configurations applies to all path matchers within the `webFormHttpSecurity` but not to `apiHttpSecurity` `SecurityWebFilterChain`.

If the URL does not start with `/api/` the `webFormHttpSecurity` configuration will be used.

