<?xml version="1.0" encoding="UTF-8"?>
<faqs title="Frequently Asked Questions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://maven.apache.org/maven-1.x/plugins/faq/faq.xsd">

    <part id="general">
    <title>General</title>
    <faq id="web-xml">
	    <question>Why not just use web.xml security?</question>
	    <answer>
	    
	    <p>Let's assume you're developing an enterprise application based on Spring.
		There are four security concerns you typically need to address: authentication,
		web request security, service layer security (i.e. your methods that implement
		business logic), and domain object instance security (i.e. different domain objects
		have different permissions). With these typical requirements in mind:
		<ol>
			<li><b>Authentication</b>: The servlet specification provides an approach
				to authentication. However, you will need to configure the container
				to perform authentication which typically requires editing of
				container-specific "realm" settings. This makes a non-portable
				configuration, and if you need to write an actual Java class to implement
				the container's authentication interface, it becomes even more non-portable.
				With Spring Security you achieve complete portability - right down to the
				WAR level. Also, Spring Security offers a choice of production-proven
				authentication providers and mechanisms, meaning you can switch your
				authentication approaches at deployment time. This is particularly
				valuable for software vendors writing products that need to work in
				an unknown target environment.<br></br><br></br></li>
			<li><b>Web request security:</b> The servlet specification provides an
				approach to secure your request URIs. However, these URIs can only be
				expressed in the servlet specification's own limited URI path format.
				Spring Security provides a far more comprehensive approach. For instance,
				you can use Ant paths or regular expressions, you can consider parts of the
				URI other than simply the requested page (eg you can consider HTTP GET
				parameters), and you can implement your own runtime source of configuration
				data. This means your web request security can be dynamically changed during
				the actual execution of your webapp.<br></br><br></br></li>
			<li><b>Service layer and domain object security:</b> The absence of support
				in the servlet specification for services layer security or domain object
				instance security represent serious limitations for multi-tiered
				applications. Typically developers either ignore these requirements, or
				implement security logic within their MVC controller code (or even worse,
				inside the views). There are serious disadvantages with this approach:<br/><br/>
					<ol>
						<li><i>Separation of concerns:</i> Authorization is a
							crosscutting concern and should be implemented as such.
							MVC controllers or views implementing authorization code
							makes it more difficult to test both the controller and
							authorization logic, more difficult to debug, and will
							often lead to code duplication.</li>
						<li><i>Support for rich clients and web services:</i> If an
							additional client type must ultimately be supported, any
							authorization code embedded within the web layer is
							non-reusable. It should be considered that Spring remoting
							exporters only export service layer beans (not MVC
							controllers). As such authorization logic needs to be
							located in the services layer to support a multitude of
							client types.</li>
						<li><i>Layering issues:</i> An MVC controller or view is simply
							the incorrect architectural layer to implement authorization
							decisions concerning services layer methods or domain object
							instances. Whilst the Principal may be passed to the services
							layer to enable it to make the authorization decision, doing
							so would introduce an additional argument on every services
							layer method. A more elegant approach is to use a ThreadLocal
							to hold the Principal, although this would likely increase
							development time to a point where it would become more
							economical (on a cost-benefit basis) to simply use a dedicated
							security framework.</li>
						<li><i>Authorisation code quality:</i> It is often said of web
							frameworks that they "make it easier to do the right things,
							and harder to do the wrong things". Security frameworks are
							the same, because they are designed in an abstract manner for
							a wide range of purposes. Writing your own authorization code
							from scratch does not provide the "design check" a framework
							would offer, and in-house authorization code will typically
							lack the improvements that emerge from widespread deployment,
							peer review and new versions.
					</li></ol>
					</li>
		</ol>
		</p>
		<p>
		For simple applications, servlet specification security may just be enough.
		Although when considered within the context of web container portability,
		configuration requirements, limited web request security flexibility, and
		non-existent services layer and domain object instance security, it becomes
		clear why developers often look to alternative solutions.
		</p>            
		</answer>
		
		</faq>

    </part>
    <part>
     	<title>Common Problems</title>
 	    <faq>
 	    	<question>My application goes into an "endless loop" when I try to login, what's going on?</question>
 	    	<answer><p>A common user problem with infinite loop and redirecting to the login page is caused 
 	    		by accidently configuring the login page as a "secured" resource. Make sure your configuration
 	    		allows anonymous access to the login page, either by excluding it from the security filter
 	    		chain or marking it as requiring ROLE_ANONYMOUS.</p>
 	    		<p>If your AccessDecisionManager includes an AutheticatedVoter, you can use the attribute
 	    			"IS_AUTHENTICATED_ANONYMOUSLY". This is automatically available if you are using the
 	    			standard namespace configuration setup.
 	    		</p>
 	    		<p>
 	    			From Spring Security 2.0.1 onwards, when you are using namespace-based configuration, a check will be made 
 	    			on loading the application context and a warning message logged if your login page appears to be protected.
 	    		</p>
 	    	</answer>
 	    </faq>
    	<faq>
    		<question>I get an exception with the message "Access is denied (user is anonymous);". What's wrong?</question>
    		<answer>
    			<p>
    			This is a debug level message which occurs the first time an anonymous user attempts to access a protected
    			resource.
    			<pre>
DEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point
org.springframework.security.AccessDeniedException: Access is denied
    at org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68)
    at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262)    				
    			</pre>
    				It is normal and shouldn't be anything to worry about.
    			</p>
    		</answer>
    	</faq>
    	<faq>
    		<question>
    			I've configured the "requires-channel" attribute to use HTTPS for my login page and switch back to HTTP afterwards but I just end up back at
    			the login page after authenticating. I'm using Tomcat. Why doesn't it work?
    		</question>
    		<answer>
    			<p>
    			This happens because Tomcat sessions created under HTTPS cannot subsequently be used under HTTP and any session state is lost (including 
    			the security context information). Starting in HTTP first should work.
    			</p>
    		</answer>
    	</faq>
    	<faq>
    		<question>
    			I'm forwarding a request to another URL using the RequestDispatcher, but my security constraints aren't being applied. Why not?
    		</question>
    		<answer>
    			Filters are not applied by default to forwards or includes. If you really want the security filters to be applied to forwards and/or includes, 
    			then you have to configure these explicitly in your web.xml using the &lt;dispatcher&gt; element, a child element of &lt;filter-mapping&gt;.
    		</answer>
    	</faq>
    </part>
	  <part>
	  	<title>Common "How To" Requests</title>
	  	<faq>
	  		<question>I need to login in with more information than just the username. How do I add support for extra login fields (e.g. a company name)?</question>
	  		<answer>
	  			<p>This question comes up repeatedly in the Spring Security forum so you will find more information there.</p>
	  			<p>
	  			The submitted login information is processed by an instance of <i>AuthenticationProcessingFilter</i>. You will need to customize this class to handle
	  				the extra data field(s). One option is to use your own customized authentication token class (rather than the standard <i>UsernamePasswordAuthenticatioToken</i>),
	  				another is simply to concatenate the extra fields with the username (for example, using a ":" as the separator) and pass them in the username property of
	  				<i>UsernamePasswordAuthenticatioToken</i>.
	  			</p>
	  			<p>
	  				You will also need to customize the actual authentication process. If you are using a custom authentication token class, for example, you will have to write an 
	  				<i>AuthenticationProvider</i> to handle it (or extend the standard <i>DaoAuthenticationProvider</i>). 
	  			  If you have concatenated the fields, you can implement your own <i>UserDetailsService</i> which splits them up and loads the appropriated user data to use
	  				for authentication.
	  			</p>
	  		</answer>
	  	</faq>
	  </part>
</faqs>  